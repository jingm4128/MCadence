/**
 * AI Insight API Route
 * 
 * POST /api/insight
 * 
 * Takes InsightStats and returns InsightV1 generated by AI.
 * Uses OpenAI or compatible provider.
 */

import { NextRequest, NextResponse } from 'next/server';
import { InsightStats, InsightV1, InsightAPIResponse, InsightAPIError } from '@/lib/ai/insight';

// ============================================================================
// Configuration
// ============================================================================

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const AI_MODEL = process.env.AI_MODEL || 'gpt-4o-mini';
const AI_TEMPERATURE = 0.3;
const AI_MAX_TOKENS = 2000;
const MAX_REQUEST_SIZE = 50 * 1024; // 50KB max request size

// ============================================================================
// System Prompt
// ============================================================================

const SYSTEM_PROMPT = `You are an AI assistant that analyzes productivity data and generates structured insights.

You will receive aggregated statistics about a user's time tracking, projects, and checklist activities for a specific period.

Your task is to generate a JSON response that matches this EXACT schema:

{
  "period": { "label": string, "start": string, "end": string, "timezone": "America/New_York" },
  "highlights": [{ "title": string, "detail"?: string, "metric"?: string }],
  "patterns": [{ "title": string, "evidence": string, "suggestion"?: string }],
  "friction": [{ "title": string, "evidence": string, "nudge"?: string, "examples"?: string[] }],
  "encouragement": { "line1": string, "line2"?: string },
  "meta": { "confidence": "low" | "medium" | "high", "notes"?: string }
}

RULES:
1. ONLY return valid JSON - no markdown, no explanation, no code blocks
2. Use ONLY the numbers and facts provided in the stats - never invent data
3. If data is missing or insufficient, set confidence to "low" and explain in meta.notes
4. Keep insights actionable and supportive, never judgmental
5. Highlights: 2-4 key achievements or facts from the period
6. Patterns: 1-3 behavioral patterns you notice (work rhythm, time distribution, etc.)
7. Friction: 0-3 areas that might need attention (stale items, low progress projects)
8. Encouragement: 1-2 lines of genuine, realistic support based on actual data
9. Truncate any project/item titles to 60 characters max
10. Arrays should have reasonable limits (max 4 highlights, 3 patterns, 3 friction, 3 examples per friction)

ARCHIVED ITEMS ANALYSIS:
The stats include data about archived items, which can reveal important behavioral patterns. Use your discretion to interpret these signals:

- checklists.dayToDay.archived: Contains unfinishedRatio (0-1) for archived daily tasks
  * High unfinished ratio MAY indicate: task instability, frequent reprioritization, overcommitment to small tasks, or healthy adaptation to changing priorities
  * Consider: Daily tasks are often reactive - some abandonment is normal and healthy

- checklists.hitMyGoal.archived: Contains unfinishedRatio (0-1) for archived goals
  * High unfinished ratio MAY indicate: goal shifts, abandoned ambitions, unrealistic goal-setting, or strategic pivots
  * Consider: Goals evolve - some abandonment reflects growth and changing priorities

- projectHealth.archived: Contains incompleteRatio (0-1) and avgProgressAtArchive (0-1) for time-tracked projects
  * High incomplete ratio MAY indicate: difficulty completing time commitments, overestimation, external disruptions, or strategic project cuts
  * Low avgProgressAtArchive MAY indicate: early abandonment patterns or projects that were created but never started
  * Consider: Project completion depends on many factors - look for patterns rather than judging individual cases

Use these archived stats to identify patterns when relevant, but DO NOT:
- Assume any single metric definitively indicates a problem
- Be judgmental about unfinished items (life happens, priorities change)
- Over-interpret small sample sizes (few archived items = low confidence in the pattern)

When you notice meaningful patterns in archived items, frame them constructively with curiosity rather than criticism.

Remember: Be helpful and insightful, but always grounded in the actual data provided.`;

// ============================================================================
// Request Validation
// ============================================================================

function validateStats(stats: unknown): stats is InsightStats {
  if (!stats || typeof stats !== 'object') return false;
  
  const s = stats as Record<string, unknown>;
  
  return (
    s.statsVersion === 'v1' &&
    typeof s.generatedAt === 'string' &&
    typeof s.period === 'object' &&
    typeof s.dataQuality === 'object' &&
    typeof s.timeTracking === 'object' &&
    typeof s.projectHealth === 'object' &&
    typeof s.checklists === 'object'
  );
}

// ============================================================================
// JSON Extraction
// ============================================================================

/**
 * Try to extract JSON from AI response, handling potential extra text.
 */
function extractJSON(text: string): InsightV1 {
  // First, try direct parse
  try {
    return JSON.parse(text);
  } catch {
    // Try to find JSON object in the text
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    throw new Error('No valid JSON found in response');
  }
}

/**
 * Validate that the response matches InsightV1 schema.
 */
function validateInsight(insight: unknown): insight is InsightV1 {
  if (!insight || typeof insight !== 'object') return false;
  
  const i = insight as Record<string, unknown>;
  
  return (
    typeof i.period === 'object' &&
    Array.isArray(i.highlights) &&
    Array.isArray(i.patterns) &&
    Array.isArray(i.friction) &&
    typeof i.encouragement === 'object' &&
    typeof i.meta === 'object'
  );
}

// ============================================================================
// API Key Validation
// ============================================================================

/**
 * Basic validation for OpenAI API key format.
 */
function isValidAPIKeyFormat(key: string): boolean {
  // OpenAI keys start with sk- and are at least 20 characters
  return typeof key === 'string' && key.startsWith('sk-') && key.length >= 20;
}

// ============================================================================
// AI Call
// ============================================================================

interface CallOpenAIOptions {
  apiKey?: string;  // User-provided key (takes priority)
  model?: string;   // User-preferred model
}

async function callOpenAI(stats: InsightStats, options: CallOpenAIOptions = {}): Promise<InsightV1> {
  // Determine which API key to use: user-provided or server env
  const apiKey = options.apiKey || OPENAI_API_KEY;
  const model = options.model || AI_MODEL;
  
  if (!apiKey) {
    throw new Error('No API key available. Please configure your OpenAI API key in settings.');
  }
  
  // Validate API key format (basic check)
  if (!isValidAPIKeyFormat(apiKey)) {
    throw new Error('Invalid API key format. OpenAI keys should start with "sk-"');
  }
  
  const userMessage = `Here are the productivity statistics to analyze:\n\n${JSON.stringify(stats, null, 2)}`;
  
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: model,
      messages: [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user', content: userMessage },
      ],
      temperature: AI_TEMPERATURE,
      max_tokens: AI_MAX_TOKENS,
      response_format: { type: 'json_object' },
    }),
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    const errorMessage = errorData.error?.message || `OpenAI API error: ${response.status}`;
    
    // Provide user-friendly error messages
    if (response.status === 401) {
      throw new Error('Invalid API key. Please check your OpenAI API key in settings.');
    } else if (response.status === 429) {
      throw new Error('Rate limit exceeded. Please try again later or check your OpenAI plan.');
    } else if (response.status === 402) {
      throw new Error('Billing issue with OpenAI account. Please check your OpenAI billing.');
    }
    
    throw new Error(errorMessage);
  }
  
  const data = await response.json();
  const content = data.choices?.[0]?.message?.content;
  
  if (!content) {
    throw new Error('Empty response from AI');
  }
  
  // Extract and validate JSON
  const insight = extractJSON(content);
  
  if (!validateInsight(insight)) {
    throw new Error('AI response does not match expected schema');
  }
  
  return insight;
}

// ============================================================================
// Route Handler
// ============================================================================

export async function POST(request: NextRequest): Promise<NextResponse<InsightAPIResponse | InsightAPIError>> {
  try {
    // Check request size
    const contentLength = request.headers.get('content-length');
    if (contentLength && parseInt(contentLength) > MAX_REQUEST_SIZE) {
      return NextResponse.json(
        { success: false, error: 'Request too large', code: 'REQUEST_TOO_LARGE' },
        { status: 413 }
      );
    }
    
    // Parse request body
    let body: { stats?: InsightStats; apiKey?: string; model?: string };
    try {
      body = await request.json();
    } catch {
      return NextResponse.json(
        { success: false, error: 'Invalid JSON body', code: 'INVALID_JSON' },
        { status: 400 }
      );
    }
    
    // Validate stats
    if (!validateStats(body.stats)) {
      return NextResponse.json(
        { success: false, error: 'Invalid stats format', code: 'INVALID_STATS' },
        { status: 400 }
      );
    }
    
    // Check if any API key is available (user-provided or server-side)
    const hasUserKey = body.apiKey && isValidAPIKeyFormat(body.apiKey);
    const hasServerKey = !!OPENAI_API_KEY;
    
    if (!hasUserKey && !hasServerKey) {
      return NextResponse.json(
        {
          success: false,
          error: 'No API key configured. Please add your OpenAI API key in AI Settings.',
          code: 'API_KEY_REQUIRED'
        },
        { status: 400 }
      );
    }
    
    // Call AI with the available key (user key takes priority)
    const insight = await callOpenAI(body.stats, {
      apiKey: body.apiKey,
      model: body.model,
    });
    
    return NextResponse.json({
      success: true,
      insight,
    });
    
  } catch (error) {
    console.error('Insight API error:', error);
    
    // Determine appropriate status code based on error
    let statusCode = 500;
    const errorMessage = error instanceof Error ? error.message : 'Internal server error';
    
    if (errorMessage.includes('Invalid API key') || errorMessage.includes('API key')) {
      statusCode = 401;
    } else if (errorMessage.includes('Rate limit')) {
      statusCode = 429;
    } else if (errorMessage.includes('Billing')) {
      statusCode = 402;
    }
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        code: 'INTERNAL_ERROR',
      },
      { status: statusCode }
    );
  }
}
