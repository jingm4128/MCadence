/**
 * AI Insight API Route
 * 
 * POST /api/insight
 * 
 * Takes InsightStats and returns InsightV1 generated by AI.
 * Supports multiple providers: OpenAI, Gemini, Anthropic.
 */

import { NextRequest, NextResponse } from 'next/server';
import { InsightStats, InsightV1, InsightAPIResponse, InsightAPIError } from '@/lib/ai/insight';
import { makeServerAICall, extractAIConfig, hasValidApiKey } from '@/lib/ai/server-config';
import { MAX_REQUEST_SIZE, extractJSONFromText, getErrorStatusCode } from '@/lib/ai/utils';

// ============================================================================
// System Prompt
// ============================================================================

const SYSTEM_PROMPT = `You are an AI assistant that analyzes productivity data and generates structured insights.

You will receive aggregated statistics about a user's time tracking, projects, and checklist activities for a specific period.

Your task is to generate a JSON response that matches this EXACT schema:

{
  "period": { "label": string, "start": string, "end": string, "timezone": "America/New_York" },
  "highlights": [{ "title": string, "detail"?: string, "metric"?: string }],
  "patterns": [{ "title": string, "evidence": string, "suggestion"?: string }],
  "friction": [{ "title": string, "evidence": string, "nudge"?: string, "examples"?: string[] }],
  "encouragement": { "line1": string, "line2"?: string },
  "meta": { "confidence": "low" | "medium" | "high", "notes"?: string }
}

RULES:
1. ONLY return valid JSON - no markdown, no explanation, no code blocks
2. Use ONLY the numbers and facts provided in the stats - never invent data
3. If data is missing or insufficient, set confidence to "low" and explain in meta.notes
4. Keep insights actionable and supportive, never judgmental
5. Highlights: 2-4 key achievements or facts from the period
6. Patterns: 1-3 behavioral patterns you notice (work rhythm, time distribution, etc.)
7. Friction: 0-3 areas that might need attention (stale items, low progress projects)
8. Encouragement: 1-2 lines of genuine, realistic support based on actual data
9. Truncate any project/item titles to 60 characters max
10. Arrays should have reasonable limits (max 4 highlights, 3 patterns, 3 friction, 3 examples per friction)

ARCHIVED ITEMS ANALYSIS:
The stats include data about archived items, which can reveal important behavioral patterns. Use your discretion to interpret these signals:

- checklists.dayToDay.archived: Contains unfinishedRatio (0-1) for archived daily tasks
  * High unfinished ratio MAY indicate: task instability, frequent reprioritization, overcommitment to small tasks, or healthy adaptation to changing priorities
  * Consider: Daily tasks are often reactive - some abandonment is normal and healthy

- checklists.hitMyGoal.archived: Contains unfinishedRatio (0-1) for archived goals
  * High unfinished ratio MAY indicate: goal shifts, abandoned ambitions, unrealistic goal-setting, or strategic pivots
  * Consider: Goals evolve - some abandonment reflects growth and changing priorities

- projectHealth.archived: Contains incompleteRatio (0-1) and avgProgressAtArchive (0-1) for time-tracked projects
  * High incomplete ratio MAY indicate: difficulty completing time commitments, overestimation, external disruptions, or strategic project cuts
  * Low avgProgressAtArchive MAY indicate: early abandonment patterns or projects that were created but never started
  * Consider: Project completion depends on many factors - look for patterns rather than judging individual cases

Use these archived stats to identify patterns when relevant, but DO NOT:
- Assume any single metric definitively indicates a problem
- Be judgmental about unfinished items (life happens, priorities change)
- Over-interpret small sample sizes (few archived items = low confidence in the pattern)

When you notice meaningful patterns in archived items, frame them constructively with curiosity rather than criticism.

Remember: Be helpful and insightful, but always grounded in the actual data provided.`;

// ============================================================================
// Request Validation
// ============================================================================

function validateStats(stats: unknown): stats is InsightStats {
  if (!stats || typeof stats !== 'object') return false;
  
  const s = stats as Record<string, unknown>;
  
  return (
    s.statsVersion === 'v1' &&
    typeof s.generatedAt === 'string' &&
    typeof s.period === 'object' &&
    typeof s.dataQuality === 'object' &&
    typeof s.timeTracking === 'object' &&
    typeof s.projectHealth === 'object' &&
    typeof s.checklists === 'object'
  );
}

/**
 * Validate that the response matches InsightV1 schema.
 */
function validateInsight(insight: unknown): insight is InsightV1 {
  if (!insight || typeof insight !== 'object') return false;
  
  const i = insight as Record<string, unknown>;
  
  return (
    typeof i.period === 'object' &&
    Array.isArray(i.highlights) &&
    Array.isArray(i.patterns) &&
    Array.isArray(i.friction) &&
    typeof i.encouragement === 'object' &&
    typeof i.meta === 'object'
  );
}

// ============================================================================
// Route Handler
// ============================================================================

export async function POST(request: NextRequest): Promise<NextResponse<InsightAPIResponse | InsightAPIError>> {
  try {
    // Check request size
    const contentLength = request.headers.get('content-length');
    if (contentLength && parseInt(contentLength) > MAX_REQUEST_SIZE) {
      return NextResponse.json(
        { success: false, error: 'Request too large', code: 'REQUEST_TOO_LARGE' },
        { status: 413 }
      );
    }
    
    // Parse request body
    let body: { stats?: InsightStats; provider?: string; apiKey?: string; model?: string; useDefaultKey?: boolean };
    try {
      body = await request.json();
    } catch {
      return NextResponse.json(
        { success: false, error: 'Invalid JSON body', code: 'INVALID_JSON' },
        { status: 400 }
      );
    }
    
    // Validate stats
    if (!validateStats(body.stats)) {
      return NextResponse.json(
        { success: false, error: 'Invalid stats format', code: 'INVALID_STATS' },
        { status: 400 }
      );
    }
    
    // Extract AI configuration
    const aiConfig = extractAIConfig(body);
    
    // Check if any API key is available
    if (!hasValidApiKey(aiConfig)) {
      return NextResponse.json(
        {
          success: false,
          error: 'No API key configured. Please add your API key in AI Settings.',
          code: 'API_KEY_REQUIRED'
        },
        { status: 400 }
      );
    }
    
    // Build user message
    const userMessage = `Here are the productivity statistics to analyze:\n\n${JSON.stringify(body.stats, null, 2)}`;
    
    // Call AI
    const content = await makeServerAICall({
      ...aiConfig,
      systemPrompt: SYSTEM_PROMPT,
      userMessage,
      temperature: 0.3,
      maxTokens: 2000,
      jsonMode: true,
    });
    
    // Extract and validate JSON
    const insight = extractJSONFromText<InsightV1>(content);
    
    if (!validateInsight(insight)) {
      throw new Error('AI response does not match expected schema');
    }
    
    return NextResponse.json({
      success: true,
      insight,
    });
    
  } catch (error) {
    console.error('Insight API error:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'Internal server error';
    const statusCode = getErrorStatusCode(errorMessage);
    
    return NextResponse.json(
      {
        success: false,
        error: errorMessage,
        code: 'INTERNAL_ERROR',
      },
      { status: statusCode }
    );
  }
}
